import EssentialFeed
import XCTest

final class KeychainHelperTests: XCTestCase {
    func test_setAndGet_returnsSavedValue() {
        let (sut, key, value) = makeRealKeychainSUT()
        let data = value.data(using: .utf8)!

        _ = sut.delete(key)
        let saveResult = sut.save(data, for: key)

        if case .success = saveResult {
            // Success
        } else {
            XCTFail("Expected success result, got \(saveResult)")
        }
        let retrievedData = sut.getData(key)

        XCTAssertNotNil(retrievedData, "Expected to retrieve some data")
        XCTAssertEqual(String(data: retrievedData!, encoding: .utf8), value, "Expected to retrieve the saved value")

        cleanUp(key: key, in: sut)
    }

    func test_get_returnsNilForNonexistentKey() {
        let (sut, key, _) = makeRealKeychainSUT()
        cleanUp(key: key, in: sut)

        XCTAssertNil(sut.getData(key), "Expected nil for non-existent key")
    }

    func test_set_overwritesPreviousValue() {
        let (sut, key, value) = makeRealKeychainSUT()
        let otherValue = "other_value"
        let valueData = value.data(using: .utf8)!
        let otherValueData = otherValue.data(using: .utf8)!

        cleanUp(key: key, in: sut)

        let firstSaveResult = sut.save(valueData, for: key)
        let secondSaveResult = sut.save(otherValueData, for: key)

        if case .failure = firstSaveResult {
            XCTFail("Expected first save to succeed")
        }
        if case .failure = secondSaveResult {
            XCTFail("Expected second save to succeed")
        }

        let retrievedData = sut.getData(key)
        XCTAssertNotNil(retrievedData)
        XCTAssertEqual(String(data: retrievedData!, encoding: .utf8), otherValue, "Expected the last saved value")

        cleanUp(key: key, in: sut)
    }

    func test_delete_removesValue() {
        let (sut, key, value) = makeRealKeychainSUT()
        let valueData = value.data(using: .utf8)!

        let saveResult = sut.save(valueData, for: key)
        if case .failure = saveResult {
            XCTFail("Expected save to succeed")
        }

        let deleteResult = sut.delete(key)
        if case .failure = deleteResult {
            XCTFail("Expected delete to succeed")
        }

        XCTAssertNil(sut.getData(key), "Expected value to be deleted")
    }

    func test_delete_nonexistentKey_doesNotFail() {
        let (sut, key, _) = makeRealKeychainSUT()
        cleanUp(key: key, in: sut)

        let deleteResult = sut.delete(key)
        if case .failure = deleteResult {
            XCTFail("Expected delete to succeed for non-existent key")
        }
        XCTAssertNil(sut.getData(key), "Expected no value for non-existent key")
    }

    func test_save_propagatesStringToDataConversionFailedError_fromDependency() {
        let sut: KeychainWritable = FailingKeychainWritable()
        let result = sut.save("irrelevant", for: "irrelevant")
        if case let .failure(error) = result {
            XCTAssertEqual(error, .stringToDataConversionFailed, "Expected .stringToDataConversionFailed, got \(error)")
        } else {
            XCTFail("Expected save to fail with .stringToDataConversionFailed error, but got .success")
        }
    }

    func test_save_validatesPostSaveRetrieval() {
        let (sut, key, value) = makeRealKeychainSUT()
        let valueData = value.data(using: .utf8)!
        cleanUp(key: key, in: sut)

        let saveResult = sut.save(valueData, for: key)

        if case .success = saveResult {
        } else {
            XCTFail("Expected success result, got \(saveResult)")
        }
        let retrievedData = sut.getData(key)
        XCTAssertNotNil(retrievedData)
        XCTAssertEqual(String(data: retrievedData!, encoding: .utf8), value, "Expected to retrieve the saved value")

        cleanUp(key: key, in: sut)
    }

    func test_get_delegatesToSpy() {
        let (sut, spy) = makeSpySUT()
        let key = "test_key"
        let expectedValue = "test_value"
        let expectedData = expectedValue.data(using: .utf8)!
        spy.stubbedData = expectedData

        let result = sut.getData(key)

        XCTAssertEqual(spy.getCalls, [key], "Expected get to be called once with the correct key")
        XCTAssertEqual(result, expectedData, "Expected the stubbed data")
    }

    func test_save_delegatesToSpy() {
        let (sut, spy) = makeSpySUT()
        let key = "test_key"
        let value = "test_value"
        let valueData = value.data(using: .utf8)!

        let result = sut.save(valueData, for: key)

        XCTAssertEqual(spy.saveCalls.count, 1, "Expected save to be called once")
        XCTAssertEqual(spy.saveCalls.first?.0, key, "Expected save with correct key")
        XCTAssertEqual(spy.saveCalls.first?.1, valueData, "Expected save with correct value data")
        if case .success = result {
            // Success
        } else {
            XCTFail("Expected success result, got \(result)")
        }
    }

    func test_save_propagatesErrorFromSpy() {
        let (sut, spy) = makeSpySUT()
        let key = "test_key"
        let value = "test_value"
        let valueData = value.data(using: .utf8)!
        let expectedError = KeychainError.duplicateItem
        spy.stubbedSaveError = expectedError

        let result = sut.save(valueData, for: key)

        if case let .failure(error) = result {
            XCTAssertEqual(error, expectedError, "Expected save to fail with the stubbed error")
        } else {
            XCTFail("Expected save to fail with error")
        }
    }

    func test_delete_delegatesToSpy() {
        let (sut, spy) = makeSpySUT()
        let key = "test_key"

        let result = sut.delete(key)

        XCTAssertEqual(spy.deleteCalls, [key], "Expected delete to be called once with the correct key")
        if case .success = result {
            // Success
        } else {
            XCTFail("Expected success result, got \(result)")
        }
    }

    func test_delete_propagatesErrorFromSpy() {
        let (sut, spy) = makeSpySUT()
        let key = "test_key"
        let expectedError = KeychainError.itemNotFound
        spy.stubbedDeleteError = expectedError

        let result = sut.delete(key)

        if case let .failure(error) = result {
            XCTAssertEqual(error, expectedError, "Expected delete to fail with the stubbed error")
        } else {
            XCTFail("Expected delete to fail with error")
        }
    }

    func test_saveData_withUnicodeKey_shouldRetrieveIdenticalData() {
        let (sut, key, value) = makeRealKeychainDataSUT(
            key: "ğŸ”‘-clave-ğŸš€-Ã¼Ã±Ã®Ã§Ã¸dÃ«-æ¼¢å­—",
            value: "Esto es un string unicode ğŸš€æ¼¢å­— convertido a Data".data(using: .utf8)!
        )
        _ = sut.delete(key)

        let saveResult = sut.save(value, for: key)
        if case .failure = saveResult { XCTFail("Expected save to succeed") }

        let retrieved = sut.getData(key)
        XCTAssertEqual(retrieved, value)

        cleanUpData(key: key, in: sut)
    }

    func test_saveLargeData_shouldRetrieveIdenticalData() {
        let largeString = String(repeating: "ğŸš€0123456789æ¼¢å­—", count: 10000)
        let largeData = largeString.data(using: .utf8)!
        let (sut, key, value) = makeRealKeychainDataSUT(
            key: "large_data_key_ğŸ—„ï¸",
            value: largeData
        )
        _ = sut.delete(key)

        let saveResult = sut.save(value, for: key)
        if case .failure = saveResult { XCTFail("Expected save to succeed") }

        let retrieved = sut.getData(key)
        XCTAssertEqual(retrieved, value)

        cleanUpData(key: key, in: sut)
    }

    func test_deleteData_withUnicodeKey_shouldRemoveData() {
        let (sut, key, value) = makeRealKeychainDataSUT(
            key: "ğŸ—‘ï¸-delete-unicode-key-æ¼¢å­—",
            value: "Data to delete".data(using: .utf8)!
        )
        _ = sut.delete(key)
        _ = sut.save(value, for: key)

        let deleteResult = sut.delete(key)
        if case .success = deleteResult {
            // Success
        } else {
            XCTFail("Expected success result, got \(deleteResult)")
        }

        let retrieved = sut.getData(key)
        XCTAssertNil(retrieved)
    }

    func test_getData_forNonexistentUnicodeKey_shouldReturnNilOrError() {
        let (sut, key, _) = makeRealKeychainDataSUT(
            key: "â“-nonexistent-unicode-key-æ¼¢å­—",
            value: Data()
        )
        _ = sut.delete(key)

        let retrieved = sut.getData(key)
        XCTAssertNil(retrieved)
    }

    func test_saveData_validatesPostSaveRetrieval() {
        let (sut, key, value) = makeRealKeychainDataSUT(
            key: "validate-post-save-æ¼¢å­—",
            value: "post-save validation data ğŸš¦".data(using: .utf8)!
        )
        _ = sut.delete(key)

        let saveResult = sut.save(value, for: key)
        if case .success = saveResult {
            // Success
        } else {
            XCTFail("Expected success result, got \(saveResult)")
        }
        let retrieved = sut.getData(key)
        XCTAssertEqual(retrieved, value)
    }

    func test_saveData_overwritesPreviousData_withDeleteBeforeAdd() {
        let (sut, key, value1) = makeRealKeychainDataSUT(
            key: "overwrite-key-æ¼¢å­—",
            value: "first value".data(using: .utf8)!
        )
        let value2 = "second value".data(using: .utf8)!
        _ = sut.delete(key)
        _ = sut.save(value1, for: key)
        let saveResult = sut.save(value2, for: key)
        if case .success = saveResult {
            // Success
        } else {
            XCTFail("Expected success result, got \(saveResult)")
        }
        let retrieved = sut.getData(key)
        XCTAssertEqual(retrieved, value2)
    }

    func test_stringOperations_remainCompatibleAfterDataSupport() {
        let (sut, key, value) = makeRealKeychainSUT(
            key: "compatibility-string-key",
            value: "string-value-compatible"
        )
        _ = sut.delete(key)
        let valueData = value.data(using: .utf8)!
        let saveResult = sut.save(valueData, for: key)
        if case .success = saveResult {
            // Success
        } else {
            XCTFail("Expected success result, got \(saveResult)")
        }
        let retrievedData = sut.getData(key)
        XCTAssertNotNil(retrievedData)
        let retrievedString = String(data: retrievedData!, encoding: .utf8)
        XCTAssertEqual(retrievedString, value)
    }

    // MARK: - Unicode Keys Tests

    func test_handleUnicodeKeys_correctly() {
        let unicodeKeys = [
            "ğŸ”‘-clave-segura-æ¼¢å­—-ğŸ˜€-ğ„-ğŸ˜º",
            "kÍeÍyÍ-wÍiÍtÍhÍ-zÍeÍrÍoÍ-wÍiÍdÍtÍhÍ-sÍpÍaÍcÍeÍsÍ",
            "kÌ¸ÌŒÍÌŒÌ½Ì‰Ì‰ÍÌŠÌ”ÍÌ½Ì½Í„Í€ÌÍ„Í†ÌÍ„ÍÌÌŒÌ½ÍÌŒÌ½Í„Ì½Ì‡ÍŒÍÌ‰ÍÌ‡Í„ÍŒÍÌŒÍ„ÍÌ‰ÍŒÍ„ÍÌŒÍ„ÍÌ‰",
            "Ù…Ø±Ø­Ø¨Ø§-Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…-ğŸ˜Š",
            "ã“ã‚“ã«ã¡ã¯-ä¸–ç•Œ-ğŸŒ",
            "ĞŸÑ€Ğ¸Ğ²ĞµÑ‚-Ğ¼Ğ¸Ñ€-ğŸš€"
        ]

        for unicodeKey in unicodeKeys {
            let (sut, key, _) = makeRealKeychainSUT()
            let testData = "Test data for key: \(unicodeKey)".data(using: .utf8)!

            _ = sut.delete(unicodeKey)

            let saveResult = sut.save(testData, for: unicodeKey)
            if case .failure = saveResult {
                XCTFail("Failed to save with Unicode key: \(unicodeKey)")
            }

            let retrievedData = sut.getData(unicodeKey)
            XCTAssertNotNil(retrievedData, "Could not retrieve data with Unicode key: \(unicodeKey)")
            XCTAssertEqual(retrievedData, testData, "Retrieved data doesn't match for key: \(unicodeKey)")

            let deleteResult = sut.delete(unicodeKey)
            if case .failure = deleteResult {
                XCTFail("Failed to delete data with Unicode key: \(unicodeKey)")
            }
            XCTAssertNil(sut.getData(unicodeKey), "Data still exists after deletion for key: \(unicodeKey)")
        }
    }

    // MARK: - Large Data Tests

    func test_handleLargeData_correctly() {
        let (sut, key, _) = makeRealKeychainSUT()
        let largeData = Data((0 ..< 1024 * 1024).map { UInt8($0 % 256) })

        _ = sut.delete(key)

        let saveResult = sut.save(largeData, for: key)
        if case .failure = saveResult {
            XCTFail("Failed to save large data")
        }

        let retrievedData = sut.getData(key)
        XCTAssertNotNil(retrievedData, "Could not retrieve large data")
        XCTAssertEqual(retrievedData, largeData, "Retrieved large data doesn't match")

        _ = sut.delete(key)
    }

    func test_validateKey_rejectsInvalidKeys() {
        let (sut, _, _) = makeRealKeychainSUT()

        let emptyKey = ""
        let emptyKeyResult = sut.save(Data(), for: emptyKey)
        if case let .failure(error) = emptyKeyResult {
            XCTAssertTrue(
                error.localizedDescription.contains("cannot be empty"),
                "Should reject empty keys"
            )
        } else {
            XCTFail("Should fail with empty key")
        }

        let longKey = String(repeating: "a", count: 300)
        let longKeyResult = sut.save(Data(), for: longKey)
        if case let .failure(error) = longKeyResult {
            XCTAssertTrue(
                error.localizedDescription.contains("exceeds maximum length"),
                "Should reject keys that are too long"
            )
        } else {
            XCTFail("Should fail with keys that are too long")
        }

        let controlKey = "key\nwith\tcontrol\rcharacters"
        let controlKeyResult = sut.save(Data(), for: controlKey)
        if case let .failure(error) = controlKeyResult {
            XCTAssertTrue(
                error.localizedDescription.contains("invalid characters"),
                "Should reject keys with control characters"
            )
        } else {
            XCTFail("Should fail with control characters in key")
        }
    }

    // MARK: - Doubles

    private final class FailingKeychainWritable: KeychainWritable {
        func save(_: Data, for _: String) -> KeychainOperationResult {
            .failure(.stringToDataConversionFailed)
        }
    }

    // MARK: - Helpers

    private func makeRealKeychainSUT(
        key: String = "test_key",
        value: String = "test_value",
        file: StaticString = #filePath,
        line: UInt = #line
    ) -> (sut: KeychainHelper, key: String, value: String) {
        let sut = KeychainHelper()
        trackForMemoryLeaks(sut as AnyObject, file: file, line: line)
        return (sut, key, value)
    }

    private func makeSpySUT(
        file: StaticString = #filePath,
        line: UInt = #line
    ) -> (sut: KeychainHelperSpy, spy: KeychainHelperSpy) {
        let spy = KeychainHelperSpy()
        trackForMemoryLeaks(spy, file: file, line: line)
        return (spy, spy)
    }

    private func makeRealKeychainDataSUT(
        key: String = "test_data_key",
        value: Data = Data(),
        file: StaticString = #filePath,
        line: UInt = #line
    ) -> (sut: KeychainHelper, key: String, value: Data) {
        let sut = KeychainHelper()
        trackForMemoryLeaks(sut as AnyObject, file: file, line: line)
        return (sut, key, value)
    }

    private func cleanUpData(key: String, in store: KeychainHelper) {
        _ = store.delete(key)
    }

    private func cleanUp(key: String, in store: KeychainHelper) {
        _ = store.delete(key)
    }

    // MARK: - Spy Helper

    private class KeychainHelperSpy: KeychainReadable, KeychainWritable, KeychainRemovable {
        var getCalls: [String] = []
        var saveCalls: [(String, Data)] = []
        var deleteCalls: [String] = []
        var stubbedData: Data?
        var stubbedSaveError: KeychainError?
        var stubbedDeleteError: KeychainError?

        func getData(_ key: String) -> Data? {
            getCalls.append(key)
            return stubbedData
        }

        func save(_ data: Data, for key: String) -> KeychainOperationResult {
            saveCalls.append((key, data))
            if let error = stubbedSaveError { return .failure(error) }
            return .success(())
        }

        func delete(_ key: String) -> KeychainOperationResult {
            deleteCalls.append(key)
            if let error = stubbedDeleteError { return .failure(error) }
            return .success(())
        }
    }
}
