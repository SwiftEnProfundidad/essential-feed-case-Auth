<rules>
  # Project Configuration
  - Language: Swift 5.9+

  # Project Structure
  - Group by features, not by type
  - Keep related files together
  - Use .lproj for localizable content

  # Architecture
  - Clean Architecture with MVVM (SwiftUI) or MVP (UIKit)
  - Strict separation of concerns
  - Unidirectional data flow
  - Feature-based modularization

  # Code Style
  - SwiftLint with custom rules
  - Maximum file length: 500 lines
  - Maximum function length: 50 lines
  - Maximum line length: 120 characters
  - Use extensions for protocol conformance
  - Group related code with MARK comments

  # Naming Conventions
  - Types: PascalCase (LoginViewController, UserProfilePresenter)
  - Variables/Functions: camelCase
  - Protocols: -able, -ing, -Type suffixes
  - Test classes: [Feature]Tests
  - Factory methods: make[Type]

  # Swift Best Practices
  - Value types (structs) by default
  - Classes only when reference semantics are needed
  - Prefer let over var
  - Use guard for early returns
  - No force unwrapping (!) or force casting (as!)
  - Prefer composition over inheritance
  - Use type inference where clear

  # Testing
  - TDD/BDD approach
  - AAA pattern (Arrange-Act-Assert)
  - Test naming: test_[method]_[scenario]_[expectedResult]
  - Use test doubles (Spies > Mocks)
  - Test one behavior per test
  - Test both success and failure paths
  - Avoid testing implementation details

  # Test Helpers
  - Use makeSUT() pattern for test setup
  - Implement Spies for protocol dependencies
  - Track memory leaks automatically
  - Use test-specific bundles for resources

  # Test Doubles (Spies)
  - Naming: [Type]Spy (e.g., LoginServiceSpy)
  - Track method calls and parameters
  - Example:
    ```
    class LoginServiceSpy: LoginServiceProtocol {
        var loginCallCount = 0
        var loginArgs: [(email: String, password: String)] = []
        
        func login(email: String, password: String) async throws -> User {
            loginCallCount += 1
            loginArgs.append((email, password))
            // Implementation for testing
        }
    }
    ```
  - Verify in tests:
    ```
    XCTAssertEqual(spy.loginCallCount, 1)
    XCTAssertEqual(spy.loginArgs.first?.email, "test@example.com")
    ```
  - Reset state in tearDown() if needed
  - Use for async/await with continuations

  # Test Setup Example
  - Use makeSUT pattern:
    ```
    private func makeSUT(
        service: LoginServiceProtocol = LoginServiceSpy(),
        file: StaticString = #filePath,
        line: UInt = #line
    ) -> (sut: LoginViewModel, spy: LoginServiceSpy) {
        let spy = service as? LoginServiceSpy ?? LoginServiceSpy()
        let sut = LoginViewModel(service: spy)
        trackForMemoryLeaks(sut, file: file, line: line)
        trackForMemoryLeaks(spy, file: file, line: line)
        return (sut, spy)
    }
    ```
  - Track memory leaks with:
    ```
    private func trackForMemoryLeaks(
        _ instance: AnyObject,
        file: StaticString = #filePath,
        line: UInt = #line
    ) {
        addTeardownBlock { [weak instance] in
            XCTAssertNil(instance, "Instance should have been deallocated", file: file, line: line)
        }
    }
    ```

  # Dependency Management
  - SPM for dependencies
  - Avoid third-party libraries unless necessary
  - No singletons for service location
  - Use dependency injection
  - Protocol-oriented dependencies

  # Git Workflow
  - Branch naming: type/ABC-123-short-description
  - Commit types: feat|fix|refactor|docs|test|chore
  - Small, focused commits
  - Pull request template required
  - Squash merge for feature branches

  # MVVM (SwiftUI) Guidelines
  - View: @ObservedObject ViewModel
  - ViewModel: ObservableObject with @Published
  - No UIKit references in ViewModels
  - @MainActor for UI updates
  - Use @Published private(set) for state
  - Handle user intents with methods

  # MVP (UIKit) Guidelines
  - View: UIViewController + protocol
  - Presenter: Handles presentation logic
  - Router: Handles navigation
  - No business logic in Views
  - Use weak references to avoid retain cycles

  # Error Handling
  - Use Result type for throwing functions
  - Meaningful error messages
  - Handle errors at the appropriate level
  - User-friendly error messages
  - Log errors for debugging

  # Performance
  - Lazy loading for heavy resources
  - Diffable data sources for collections
  - Profile with Instruments regularly
  - Optimize image assets
  - Use appropriate QoS classes

  # Documentation
  - Document public APIs
  - Use /// for documentation
  - Update README with setup
  - Document complex algorithms
  - Keep changelog updated

  # Memory Management
  - Use weak/unowned properly
  - Check for retain cycles
  - Use Instruments for leaks
  - Be careful with closures
  - Use capture lists appropriately

  # Concurrency
  - Use async/await
  - MainActor for UI updates
  - Thread safety with actors
  - Use Task for background work
  - Handle task cancellation

  # Localization
  - Use NSLocalizedString
  - Keep strings in Localizable.strings
  - Support RTL languages
  - Test with different locales
  - Support dynamic type

  # Accessibility
  - Support Dynamic Type
  - VoiceOver support
  - Sufficient contrast ratios
  - Accessibility identifiers for UI tests
  - Support Voice Control

  # Security
  - Use Keychain for sensitive data
  - Certificate pinning
  - Input validation
  - Use HTTPS exclusively
  - Sanitize user input
  - Secure token management
  - SQL injection protection
  - SSL certificate validation
  - Biometric authentication support
  - Secure file storage

  # CI/CD
  - Fastlane for automation
  - Unit test coverage > 80%
  - UI tests for critical paths
  - Automatic code signing
  - Beta distribution
  - Static code analysis
  - Integration tests
  - Automated deployment
  - Code coverage reports
  - Performance testing

  # Code Review
  - Small PRs (< 400 lines)
  - Clear descriptions
  - Required approvals: 1
  - Address technical debt
  - Follow SOLID principles
  - Check for memory leaks
  - Verify error handling
  - Ensure accessibility compliance

  # Dependency Injection
  - Use @Dependency for DI
  - @Environment for global dependencies
  - Protocol-based dependencies
  - Testable dependency injection
  - Scoped dependencies

  # UI/UX
  - Dark/Light mode support
  - Adaptive layouts
  - Haptic feedback
  - Loading states
  - Empty states
  - Error states
  - Pull-to-refresh
  - Infinite scrolling

  # Analytics & Monitoring
  - Track user interactions
  - Crash reporting
  - Performance monitoring
  - Custom event tracking
  - User journey analysis

  # Build & Performance
  - Enable build optimizations
  - Use assets catalogs
  - Lazy load modules
  - Optimize asset sizes
  - Monitor build times

  # Development Workflow
  - Feature flags
  - Environment configurations
  - Mock API responses
  - Development tools
  - Debug menu
</rules>